#+TITLE: データ構造と関数
#+AUTHOR: 村田 昇
#+EMAIL: noboru.murata@eb.waseda.ac.jp
#+DATE: 2019.04.19
:preamble:
#+INCLUDE: "./myconf.org"
#+STARTUP: hidestars content
# C-c C-x C-v でinlineを切り替え
# <l C-i でlatex block
# C-c '
#+OPTIONS: LaTeX:t    
#+PROPERTY: results output
#+PROPERTY: exports both
:end:

* データ構造
**  Rに用意されているデータ構造
   下記は代表的なもので，これ以外にもある
   - ベクトル (vector)
   - 行列 (matrix)
   - リスト (list) 
   - データフレーム (data frame)
   - 配列 (array)

* データ構造: ベクトル
**  ベクトルとは
   - スカラー値の集合  
   - スカラー値として扱われるものには
     - 数値 (実数や複素数)
     - 文字列 ('や"で囲まれた文字．"foo"，"bar"など)
     - 論理値 ( ~TRUE~ , ~FALSE~ )
     などが含まれる 
   - Rオブジェクトの多くはベクトルとして扱われる\\
     (スカラー値は長さ1のベクトルとして扱われる) 

** ベクトルの生成と操作
   - 数値や文字列の要素からなるベクトルの生成:
     #+begin_src R :exports both :results output
       c(1,-2,3,-4,5) # 数値のベクトル
       c("Alice","Bob","Cathy","David") # 文字列のベクトル
     #+end_src
   - ベクトルの要素の取得:
     #+begin_src R :exports code
       x[i] # xの第i要素 (ベクトルの添え字は1から始まる)
       x[c(1,3,4)] # 複数の要素
		   # = c(x[1],x[3],x[4])
     #+end_src
   - ベクトル ~x~ の長さの取得:
     #+begin_src R :exports code
       length(x)    
     #+end_src

** ベクトルの作成と操作 (その2)
   - 実数 ~x~ から ~y~ まで
     1ずつ変化する要素を持つベクトル:
     #+begin_src R :exports code
       x:y # x < y の場合は1ずつ増加，逆の場合は1ずつ減少
     #+end_src
   # x<yの場合は1ずつ増加，x>yの場合は1ずつ減少
   - 実数 ~x~ から ~y~ まで
     ~a~ ずつ変化する要素を持つベクトル:
     #+begin_src R :exports code
       seq(x,y,by=a) # from=x,to=y と明示してもよい    
     #+end_src
   - ベクトル ~x~ を ~n~ 回繰り返した要素をもつベクトル:
     #+begin_src R :exports code
       rep(x,n) # 長さは length(x) * n となる
     #+end_src
   - ベクトル ~x~ とベクトル ~y~ の結合:
     #+begin_src R :exports code
       c(x,y)    
     #+end_src
   - ベクトル ~x~ の反転:
     #+begin_src R :exports code
       rev(x)    
     #+end_src

** 演習
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 以下に示すベクトルを作成せよ.
     - 1から10までの自然数のベクトル
     - 1以上30以下の奇数を昇順に並べたベクトル
     - すべての要素が1からなる長さ10のベクトル

*  データ構造: 行列
** 行列の生成と操作
   - すべての要素が ~a~ である $m\times n$ 行列:
     #+begin_src R :exports code
       matrix(a,m,n)     
     #+end_src
   - 長さ $mn$ のベクトル ~x~ を $m\times n$ 行列に変換:
     # #+begin_export latex
     \begin{equation}
       x=(x_{11},\dots,x_{m1},x_{21},\dots,x_{2n},\dots,x_{m1},\dots,x_{mn})
     \end{equation}
     # #+end_export
     #+begin_src R :exports code
       matrix(x,m,n)    
     #+end_src
     # ただし
     # % $x=(x_{11},\dotsc,x_{m1},x_{21},\dotsc,x_{m1},\dotsc,x_{mn})$
     # % $(x_{ij})_{1\leq i\leq m,1\leq n}$
   - 関数 ~as.vector()~ を用いたベクトル化:
     #+begin_src R :exports code
       x <- as.vector(matrix(x,m,n))
     #+end_src 

** 行列の生成と操作 (その2)
   - 行列のサイズの取得: 
     #+begin_src R :exports code
       dim(X) # 長さ2のベクトル
       nrow(X) # 行数
       ncol(X) # 列数
     #+end_src
   - 関数 ~dim()~ によるベクトルから行列への変換:
     #+begin_src R :exports code
       dim(x) <- c(m,n) # = matrix(x,m,n)
     #+end_src
   - 行列の成分の取得:
     #+begin_src R :exports code
       X[i,j] # (i,j)成分
       X[i, ] # 第i行
       X[ ,j] # 第j列
       X[c(1,3),2:4] # 1，3行と，2〜4列からなる部分行列
     #+end_src
     # ベクトルの場合と同様に，
     # 添え字をベクトルで指定することで部分行列の取り出しも可能
   - 長さが等しい複数のベクトルの結合:
     #+begin_src R :exports code
       rbind(x, y, ...) # 行ベクトルとして結合
       cbind(x, y, ...) # 列ベクトルとして結合
     #+end_src
     # ~cbind()/rbind()~ は行列の結合にも使える

** 行列の生成と操作 - 補足
     - 関数 ~cbind()/rbind()~ は行数/列数が等しい行列を横/縦に結合できる
     - 行列の高次元版として配列(array)が用意されている

** 演習
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 以下に示す行列を作成せよ．
     # #+begin_export latex
     \begin{equation*}
       \begin{pmatrix}
         1  & 2  & 3  \\
         4  & 5  & 6 
       \end{pmatrix}
     \end{equation*}
     # #+end_export
   
*  データ構造: リスト
** リストとは
   - 異なる構造のデータを1つにまとめたもの
     # リストの各要素は異なるデータ型・クラスであって構わない
   - 本講義のデータ解析ではほとんど用いない
   - Rの関数の操作ではときどき必要

** リストの生成と操作
   - リストの生成:
     #+begin_src R :exports code
       L <- list(x,y) # x,yを要素とするリスト
       L[[i]] # リストの第i要素
     #+end_src
   - リストの各要素に名前を付与:
     #+begin_src R :exports code
       L1 <- list(first=x, second=y) # 方法1
       L2 <- list(x,y)               # 方法2
       names(L2) <- c("first","second")
     #+end_src
   - 名前によるリストの要素の取得:
     #+begin_src R :exports code
       L1$first      # 方法1
       L2[["first"]] # 方法2
     #+end_src

*  データ構造: データフレーム
** データフレームとは
   - リストにおける各要素が長さの等しいベクトルであるもの 
     # (データ型はバラバラでも良い)
   - 複数の個体について，いくつかの属性を集計したデータ
   - 例: ある小学校の1年生の身長・体重・性別・血液型など
     - 各成分はある属性に関する観測データに対応 
     - 個体数は集計項目に関わらず変化しないが，
       集計項目によっては定量的データ・定性的データの違いが出てくるので
       データ型は変わりうる
   - 実データの多くは表形式で与えられるため，
     実データに則したデータ構造

** データフレームの生成と操作
   - データフレームの生成:
     #+begin_src R :exports code
       data.frame(A=x,B=y,C=z) # x,y,zは同じ長さ，各列はA,B,Cという名前
     #+end_src
   - データフレームはリストでもある\\
     リストと同様にして各変数にアクセスできる
   - データフレームは行列でもある\\
     行数がベクトルの長さ(個体数), 列数が変数の個数(観測項目の数)の行列と同様にアクセスできる

** 演習
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 次の表に対応するデータフレームを作成せよ．
     |-------+------+------+------|
     |       | 国語 | 数学 | 英語 |
     |-------+------+------+------|
     | Alice |   90 |   25 |   65 |
     | Bob   |   80 |   50 |  100 |
     | Cathy |   70 |   75 |   70 |
     | David |   60 |  100 |   40 |
     |-------+------+------+------|
  
* ベクトルの計算
** ベクトルの表記
   - ベクトルは太字で表し，要素は下付き添字で表す
   - 例えば $k$ 次元ベクトルは以下のように表す
     # #+begin_export latex
     \begin{equation}
       \boldsymbol{a}
       =(a_{1},a_{2},\dotsc,a_{k})
     \end{equation}
     # #+end_export
   - ベクトル $\boldsymbol{a}$ の第 $i$ 成分を $(\boldsymbol{a})_{i}$ のように書くこともある
   # - 対応するRのオブジェクトはタイプライタ体で表記する
   #   #+begin_src R :exports code
   #   a
   #   #+end_src
   #   # % 

** ベクトルの加法
   - 同じ長さのベクトルの和および差は，
     数値の和と差のように扱うことができる
     # #+begin_export latex
     \begin{equation}
       \boldsymbol{a}\pm\boldsymbol{b}
       =(a_{1}\pm b_{1},a_{2}\pm b_{2},\dotsc,a_{k}\pm b_{k})
     \end{equation}
     # #+end_export
     #+begin_src R :exports code
       a + b # 同じ長さのベクトル a,b の和
       a - b # ベクトルの差
     #+end_src
     # ~a, b~ が同じ長さのベクトルであればによって和を計算できる

** ベクトルの乗法 (2種類)
   - 同じ長さの2つのベクトル $\boldsymbol{a},\boldsymbol{b}$ の
     成分ごとの積(Hadamard積)を計算する
     # #+begin_export latex
     \begin{equation}
       \boldsymbol{a}\circ\boldsymbol{b}
       =(a_{1}b_{1},a_{2}b_{2},\dotsc,a_{k}b_{k})
     \end{equation}
     # #+end_export
     #+begin_src R :exports code
       a * b # ベクトルの成分ごとの積
     #+end_src
   - ベクトルの内積を計算する
     # #+begin_export latex
     \begin{equation}
       \boldsymbol{a}\cdot\boldsymbol{b}
       =\sum_{i=1}^{k}a_{i}b_{i}
     \end{equation}
     # #+end_export
     #+begin_src R :exports code
       a %*% b # ベクトルの内積
     #+end_src

** 初等関数の適用
   - ベクトルに初等関数( $\sin,\exp,\dots$ など)を適用すると, 
     成分ごとに計算した結果が返される
   - 例えばベクトル $\boldsymbol{a}$ に関数 $\sin$ を適用した
     結果は
     # #+begin_export latex
     \begin{equation}
       \sin(\boldsymbol{a})=(\sin(a_1),\dots,\sin(a_k))
     \end{equation}
     # #+end_export
     となる
     #+begin_src R :exports code
       sin(a) # 成分ごとに計算される．sin(a)[i]=sin(a[i])
     #+end_src

** 演習
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 以下に示すベクトルを作成せよ.
     - 1から10までの2乗値からなるベクトル
     - 0度から30度刻みで360度まで正弦関数の値を並べたベクトル
     - 公比10の1から10000までの等比数列からなるベクトル

* 行列の計算
** 行列の表記
  - 行列は大文字で表し，要素は下付き添字で表す
  - 例えば $m\times n$ 行列は
    # #+begin_export latex
    \begin{equation}
      A
      =
      \begin{pmatrix}
	a_{11}&a_{12}&\dots&a_{1n}\\
	a_{21}&a_{22}&\dots&a_{2n}\\
	\vdots&&\ddots&\vdots\\
	a_{m1}&a_{m2}&\dots&a_{mn}
      \end{pmatrix}
    \end{equation}
    # #+end_export
    のように表す
  - 行列 $A$ の $ij$ 成分を $(A)_{ij}$ のように書くこともある
  # - (対応するRオブジェクトはタイプライタ体)

**   行列の加法
  - 同じ大きさの行列の和および差
    # #+begin_export latex
    \begin{equation}
      (A\pm B)_{ij}=a_{ij}\pm b_{ij}
    \end{equation}
    # #+end_export
    は，ベクトルと同じように記述することができる
    #+begin_src R :exports code
      A + B # 同じサイズの行列の和
    #+end_src

** 行列の乗法 (2種類)
  - 同じ大きさの行列の成分ごとの積(Hadamard積)を計算する
     # #+begin_export latex
     \begin{equation}
       (A\circ B)_{ij}=a_{ij}b_{ij}
     \end{equation}
     # #+end_export
    #+begin_src R :exports code
      A * B # 行列の成分ごとの積
    #+end_src
  - $n\times m$ 型行列 $A$ と $m\times l$ 型行列 $B$ の
    積 $AB$ を計算する
    # #+begin_export latex
    \begin{equation}
      (AB)_{ij}=\sum_{k=1}^{m}a_{ik}b_{kj}
      \quad\text{($AB$は$n\times l$行列)}
    \end{equation}
    # #+end_export
    #+begin_src R :exports code
      A %*% B # 行列の積
    #+end_src

** 初等関数の適用
  - 行列に初等関数( $\sin,\exp,\dots$ など)を適用すると，
    成分ごとに計算した結果が返される
  - 例えば行列 $A$ に関数 $\sin$ を適用した
    結果の $(i,j)$ 成分は
    # #+begin_export latex
    \begin{equation}
      (\sin(A))_{ij}=\sin(a_{ij})
    \end{equation}
    # #+end_export
    で与えられる
    #+begin_src R :exports code
      sin(A) # 成分ごとに計算される．サイズは行列Aと同じ．sin(A)[i,j]=sin(A[i,j])
    #+end_src

** 行列式，トレース，逆行列
  - 正方行列 $A$ の行列式 $\det(A)$ を計算する
    #+begin_src R :exports code
      det(A) # 行列式
    #+end_src
  - $n$ 次正方行列 $A$ のトレース(対角成分の総和)
    # #+begin_export latex
    \begin{equation}
      \mathrm{trace}(A)=\sum_{i=1}^na_{ii}
    \end{equation}
    # #+end_export
    は，
    行列の対角成分を取り出す ~diag()~ と
    ベクトルの総和を計算する ~sum()~ を組み合わせて計算する
    #+begin_src R :exports code
      sum(diag(A)) # 行列のトレース
    #+end_src
  - 正則な行列 $A$ の逆行列 $A^{-1}$ は関数 ~solve()~ で計算する
    #+begin_src R :exports code
      solve(A) # 逆行列
    #+end_src

** 演習
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 適当な2次正方行列 $A$ を作成し，
     Hamilton-Cayleyの定理
     # #+begin_export latex
     \begin{equation}
       A^2-\mathrm{trace}(A)A+\det(A)E_2=O
     \end{equation}
     # #+end_export
     の成立を確認せよ．\\
     ただし $E_2$ は2次単位行列，$O$ は2次正方零行列である．

* ベクトルと行列の計算
** ベクトルと行列の乗法
  - R言語においては，
    列ベクトル・行ベクトルという区別はなく，
    単一のベクトルという概念で扱われている
  - 行列とベクトルの積においては，
    行列のどちらからベクトルを掛けるかによって自動的に列ベクトルか行ベクトルか適切な方で扱われる
  - ベクトルも行列の一種であり計算結果は行列として表現されることに注意する
** 連立方程式
  - $A$ が $n$ 次正則行列，
    $\boldsymbol{b}$ が $n$ 次元列ベクトルのとき，
    $\boldsymbol{x}$ に関する連立1次方程式
    # #+begin_export latex
    \begin{equation}
      A\boldsymbol{x}=\boldsymbol{b}
    \end{equation}
    # #+end_export
    は解 $\boldsymbol{x}=A^{-1}\boldsymbol{b}$ をもつが，
    この解は関数 ~solve()~ によって計算できる
    #+begin_src R :exports code
    x <- solve(A, b)    
    #+end_src
  - ベクトル $\boldsymbol{b}$ は行数 $n$ の行列でも可能

** 演習
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 適当な3次正方行列 $A$ と3次元ベクトル $\boldsymbol{b}$ を作成し，
     $\boldsymbol{x}$ に関する連立1次方程式
     # #+begin_export latex
     \begin{equation}
       A\boldsymbol{x}=\boldsymbol{b}
     \end{equation}
     # #+end_export
     を解け．
   - 上の $A$ と $\boldsymbol{b}$ を用いて
     #+begin_src R :exports code
       A %*% b + b %*% A   
     #+end_src
     を計算せよ(エラーになる)．なぜそうなるか理由を考えよ．

* 関数定義
** 関数定義
  - 多くの計算機言語と同様にRでも自作関数を定義できる   
  - 自作関数の定義には関数 ~function()~ を利用する 
  - 例: 半径 r から球の体積と表面積を求める
    #+begin_src R :exports code
      myfunc <- function(r){
	  V <- (4/3) * pi * r^3 # 球の体積
	  S <- 4 * pi * r^2     # 球の表面積
	  out <- c(V,S)
	  names(out) <- c("volume", "area") 
	  ## 返り値に名前をつける
	  return(out)
      }
      myfunc(1) # 実行
    #+end_src

** 演習
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 三角形の3辺の長さ $x,y,z$ を与えると面積 $S$ を計算する関数を作成せよ．
   - そのコードをarea.Rという名前のファイルで保存せよ．
   - 関数 ~source()~ で上記のファイルを読み込んで，
     $x=3$, $y=4$, $z=5$ として計算してみよ．\\
     なお``ヘロンの公式''より
     # #+begin_export latex
     \begin{equation}
       S=\sqrt{s(s-x)(s-y)(s-z)},\qquad
       s=\frac{x+y+z}{2}
     \end{equation}
     # #+end_export
     が成り立つ．

* 制御構造
** 制御文
   - 最適化や数値計算などを行うためには，
     条件分岐や繰り返しを行うための仕組みが必要となる
   - R言語を含む多くの計算機言語では
     - ~if~  (条件分岐)
     - ~for~  (繰り返し・回数指定)
     - ~while~  (繰り返し・条件指定) 
     を用いた構文が用意されているが，
     これを制御文と言う 

** ~if~ 文
  - 条件Aが満たされる場合プログラムXを実行する
    #+begin_src R :exports code
      if(条件A) プログラムX
    #+end_src
  - 条件Aが満たされない場合は
    プログラムYを実行することを追加する
    #+begin_src R :exports code
      if(条件A) プログラムX else プログラムY    
    #+end_src

** ~for~ 文
  -  ~M~ をベクトルとし，
    変数 ~i~ が ~M~ の要素となる値すべてを動きながら
    プログラムXを繰り返し実行する
    #+begin_src R :exports code
      for(i in M) プログラムX
    #+end_src
  - プログラムXは通常変数 ~i~ によって実行内容が変わる

** ~while~ 文
  - 条件Aが満たされる限りプログラムXを繰り返し実行する
    #+begin_src R :exports code
      while(条件A) プログラムX
    #+end_src
  - プログラムXは通常実行するたびに実行内容が変わり，
    いつか条件Aが満たされなくなるように書く
  - 参考: ~repeat~ 文というのある

# ** ~repeat~ 文
#    - プログラムXを繰り返し実行
#      #+begin_src R :exports code
#        repeat プログラムX
#      #+end_src
#    - プログラムXには
#      #+begin_src R :exports code
#        if(条件A) break
#      #+end_src
#      という記述が含まれている必要がある．
#      この記述は，「条件Aが成立したら繰り返しをやめる」という意味

** 演習
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - ~for~ 文を用いて以下の計算をする関数を作成し，
     正しく動作するか適当な値を入れて確認せよ．
     - 正の整数 $n$ から階乗 $n!$ を計算する．
     - 行列 $X$ が与えられたとき，各列の平均を計算する．\\
       (動作確認は, 例えば以下の行列を利用せよ)
       # #+begin_export latex
       \begin{equation}
	 X=
	 \begin{pmatrix}
	   1  & 2  & 3  \\
	   4  & 5  & 6  \\
	   7  & 8  & 9  
	 \end{pmatrix}
       \end{equation}
       # #+end_export
  
** 演習
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - ~for~ 文の問題で作成したそれぞれの関数が，
     以下の処理をできるように ~if~ 文を用いて修正せよ．
     - $n=0$ の場合にも関数が正しく動作する( $0!=1$ )．
     - $X$ がベクトルの場合でも正しく動作する．
  
** 演習
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - ~while~ 文を用いて以下の計算をする関数を作成し，
     正しく動作するか適当な数値を入れて確認せよ．
     - 正の整数 $n$ から $n!$ を計算する．
     - 正の実数 $x$ から $x\leq n$ を満たす最小の整数 $n$ を計算する．
